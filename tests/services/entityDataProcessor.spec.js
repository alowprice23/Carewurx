const EntityDataProcessor = require('../../services/entityDataProcessor');

// Mock FirebaseService (admin version)
const mockFirebaseService = {
  getDocument: jest.fn(),
  addDocument: jest.fn(),
  updateDocument: jest.fn(),
  // setDocument: jest.fn(), // If we were to use set for known IDs
};

describe('EntityDataProcessor', () => {
  let processor;

  beforeEach(() => {
    jest.clearAllMocks();
    processor = new EntityDataProcessor(mockFirebaseService);
  });

  describe('constructor', () => {
    it('should throw if FirebaseService instance is not provided', () => {
      expect(() => new EntityDataProcessor(null)).toThrow('FirebaseService instance is required');
    });
  });

  describe('_getCollectionName', () => {
    it('should return correct collection names for known entity types', () => {
      expect(processor._getCollectionName('client')).toBe('clients');
      expect(processor._getCollectionName('caregiver')).toBe('caregivers');
      expect(processor._getCollectionName('schedule')).toBe('schedules');
    });

    it('should throw for an unknown entity type', () => {
      expect(() => processor._getCollectionName('unknown')).toThrow('Unknown entity type: "unknown"');
    });
  });

  describe('processEntities', () => {
    const mockClientEntities = [
      { name: 'New Client A' }, // New
      { id: 'client123', name: 'Existing Client B Updated' }, // Existing
      { name: 'New Client C With ID', id: 'clientABC' }, // New, but ID provided and not found
      { name: 'Client D Fails' }, // Will cause add error
    ];
    const entityType = 'client';
    const collectionName = 'clients';

    it('should return empty counts for empty entities array', async () => {
      const result = await processor.processEntities([], entityType);
      expect(result).toEqual({ addedCount: 0, updatedCount: 0, failedCount: 0, errors: [] });
    });

    it('should fail all entities if entityType is invalid', async () => {
      const entities = [{ name: 'Test' }];
      const result = await processor.processEntities(entities, 'invalidType');
      expect(result.addedCount).toBe(0);
      expect(result.updatedCount).toBe(0);
      expect(result.failedCount).toBe(entities.length);
      expect(result.errors.length).toBe(entities.length);
      expect(result.errors[0].errorMessage).toContain('Unknown entity type: "invalidType"');
    });

    it('should skip and log error for invalid entity objects in the array', async () => {
        const entities = [ {name: "Valid"}, null, {name: "Another Valid"}];
        mockFirebaseService.addDocument.mockResolvedValue({ id: 'newId' });
        const result = await processor.processEntities(entities, entityType);
        expect(result.addedCount).toBe(2);
        expect(result.failedCount).toBe(1);
        expect(result.errors.length).toBe(1);
        expect(result.errors[0].errorMessage).toBe('Invalid entity object encountered.');
    });

    it('should process a mix of new, existing, and erroring entities', async () => {
      // Setup mocks:
      // 1. New Client A (no ID) -> addDocument success
      mockFirebaseService.addDocument
        .mockResolvedValueOnce({ id: 'newClientA_ID', ...mockClientEntities[0] });

      // 2. Existing Client B (id: 'client123') -> getDocument finds it, updateDocument success
      mockFirebaseService.getDocument.mockResolvedValueOnce({ id: 'client123', name: 'Existing Client B Original' });
      mockFirebaseService.updateDocument.mockResolvedValueOnce({ id: 'client123' });

      // 3. New Client C With ID (id: 'clientABC') -> getDocument does NOT find it, so it's added (new ID generated by Firestore)
      mockFirebaseService.getDocument.mockResolvedValueOnce(null); // Not found
      mockFirebaseService.addDocument
        .mockResolvedValueOnce({ id: 'newClientC_ID_firestore', ...mockClientEntities[2] }); // Firestore generates new ID

      // 4. Client D Fails (no ID) -> addDocument fails
      mockFirebaseService.addDocument.mockRejectedValueOnce(new Error('Failed to add Client D'));

      const results = await processor.processEntities(mockClientEntities, entityType);

      expect(results.addedCount).toBe(2); // Client A, Client C (with new ID)
      expect(results.updatedCount).toBe(1); // Client B
      expect(results.failedCount).toBe(1); // Client D
      expect(results.errors.length).toBe(1);
      expect(results.errors[0].entityData.name).toBe('Client D Fails');
      expect(results.errors[0].errorMessage).toBe('Failed to add Client D');

      // Verify calls
      // Add Client A
      expect(mockFirebaseService.addDocument).toHaveBeenCalledWith(collectionName, { name: 'New Client A' });

      // Update Client B
      expect(mockFirebaseService.getDocument).toHaveBeenCalledWith(collectionName, 'client123');
      const expectedUpdateDataB = { name: 'Existing Client B Updated' }; // id is removed by processor
      expect(mockFirebaseService.updateDocument).toHaveBeenCalledWith(collectionName, 'client123', expectedUpdateDataB);

      // Add Client C (original ID 'clientABC' was provided but not found)
      expect(mockFirebaseService.getDocument).toHaveBeenCalledWith(collectionName, 'clientABC');
      const expectedAddDataC = { name: 'New Client C With ID' }; // id 'clientABC' is removed by processor before add
      expect(mockFirebaseService.addDocument).toHaveBeenCalledWith(collectionName, expectedAddDataC);

      // Add Client D (fails)
      expect(mockFirebaseService.addDocument).toHaveBeenCalledWith(collectionName, { name: 'Client D Fails' });
    });

    it('should correctly call addDocument for entities without an ID', async () => {
      const newEntities = [{ name: 'Only New 1' }, { name: 'Only New 2' }];
      mockFirebaseService.addDocument.mockResolvedValue({ id: 'someNewId' });

      const results = await processor.processEntities(newEntities, entityType);

      expect(results.addedCount).toBe(2);
      expect(results.updatedCount).toBe(0);
      expect(results.failedCount).toBe(0);
      expect(mockFirebaseService.addDocument).toHaveBeenCalledTimes(2);
      expect(mockFirebaseService.addDocument).toHaveBeenCalledWith(collectionName, newEntities[0]);
      expect(mockFirebaseService.addDocument).toHaveBeenCalledWith(collectionName, newEntities[1]);
      expect(mockFirebaseService.getDocument).not.toHaveBeenCalled();
      expect(mockFirebaseService.updateDocument).not.toHaveBeenCalled();
    });

    it('should correctly call updateDocument for entities with an ID that exists', async () => {
      const existingEntities = [
        { id: 'e1', name: 'Existing E1 Updated' },
        { id: 'e2', name: 'Existing E2 Updated' },
      ];
      mockFirebaseService.getDocument.mockResolvedValue({ id: 'e1', name: 'Existing E1 Original' }); // Mock that both exist
      mockFirebaseService.updateDocument.mockResolvedValue({ id: 'e1' });

      const results = await processor.processEntities(existingEntities, entityType);

      expect(results.addedCount).toBe(0);
      expect(results.updatedCount).toBe(2);
      expect(results.failedCount).toBe(0);
      expect(mockFirebaseService.getDocument).toHaveBeenCalledTimes(2);
      expect(mockFirebaseService.getDocument).toHaveBeenCalledWith(collectionName, 'e1');
      expect(mockFirebaseService.getDocument).toHaveBeenCalledWith(collectionName, 'e2');
      expect(mockFirebaseService.updateDocument).toHaveBeenCalledTimes(2);
      expect(mockFirebaseService.updateDocument).toHaveBeenCalledWith(collectionName, 'e1', { name: 'Existing E1 Updated' });
      expect(mockFirebaseService.updateDocument).toHaveBeenCalledWith(collectionName, 'e2', { name: 'Existing E2 Updated' });
      expect(mockFirebaseService.addDocument).not.toHaveBeenCalled();
    });

    it('should handle errors from updateDocument', async () => {
        const entityWithError = { id: 'updateFailId', name: 'Update Fail Client' };
        mockFirebaseService.getDocument.mockResolvedValue({ id: 'updateFailId', name: 'Original' });
        mockFirebaseService.updateDocument.mockRejectedValue(new Error('Update failed in DB'));

        const results = await processor.processEntities([entityWithError], entityType);
        expect(results.updatedCount).toBe(0);
        expect(results.failedCount).toBe(1);
        expect(results.errors[0].errorMessage).toBe('Update failed in DB');
    });
  });
});
